---
author: Boyu Ren
pubDatetime: &id001 2021-12-27 20:13:32
modDatetime: *id001
title: 24-基本分页存储管理
slug: 24-基本分页存储管理
featured: false
draft: false
tags:
- 操作系统
description: 从之前文章介绍的两种连续分配管理方式中我们可以看到：
---

# 非连续分配管理方式-基本分页存储管理

从之前文章介绍的两种连续分配管理方式中我们可以看到：
- 固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率很低
- 动态分区分配：会产生大量外部碎片，虽然可以用紧凑技术处理，但时间成本会增加

考虑到连续分配方式的缺陷，人们考虑到如果可以将一个进程分散然后分别装入到不相邻分区中就可以更加高效利用内存，基于这一思想，产生了“非连续分配方式”也成为离散分配方式

## 把“固定分区分配”改造为“非连续分配”

假设进程A大小为23MB，但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。
> 解决思路:如果允许进程占用多个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中(这些分区不要求连续）...

进程A的最后一个部分是3MB，放入分区后会产生7MB的内部碎片。
如果每个分区大小为2MB，那么进程A可以拆分成11*2MB +1MB共12个部分，只有最后一部分1MB占不满分区，会产生1MB的内部碎片。
显然，如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。

上面这种思想就是“基本分页存储管理”的思想――把内存分为一个个相等的小分区,再按照分区大小把进程拆分成一个个小部分

## 分页存储管理的基本概念

将内存空间分为一个个大小相等的分区（比如:每个分区4KB），每个分区就是一个“页框”，或称“页帧”、“内存块”、“物理块”。每个页框有一个编号，即“页框号”(或者“内存块号”、“页帧号”、“物理块号”)页框号从0开始。

将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始。（注:进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。

各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227202745.png)


### 实现地址转换

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203210.png)

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203335.png)

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227203543.png)


结论:如果每个页面大小为2^K B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。


分页存储管理的逻辑地址结构如下所示:

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227204258.png)

地址结构包含两个部分:前一部分为页号，后一部分为页内偏移量w。在上图所示的例子中，地址长度为32位，其中0~11位为“页内偏移量”，或称“页内地址”，12~31位为“页号”。

- 如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2^K个内存单元
- 如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2^M个页面

要如何知道该页号对应在内存中的起始地址

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227204930.png)



![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211227205435.png)


## 基本地址变换机构

（基本地址变换机构是用于实现逻辑地址到物理地址转换的一组硬件机构）

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229164109.png)


设页面大小为L，逻辑地址A到物理地址E的变换过程如下：
1. 计算页号Р和页内偏移量W（如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）
2. 比较页号P和页表长度M，若P>=M，则产生越界中断，否则继续执行。（注意:页号是从O开始的，而页表长度至少是1，因此 P=M时也会越界）
3. 页表中页号P对应的页表项地址=页表起始地址F+页号P*页表项长度，取出该页表项内容b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页;页表项长度指的是每个页表项占多大的存储空间;页面大小指的是一个页面占多大的存储空间）
④计算E= b*L+W，用得到的物理地址E去访问内存。（如果内存块号、页面偏移量是用二进制表示的,那么把二者拼接起来就是最终的物理地址了）

### 示例
例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。

> 等价描述:某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。

1. 计算页号、页内偏移量
    - 页号P=A/L = 2500/1024 =2
    - 页内偏移量W=A%L= 2500%1024= 452
2. 根据题中条件可知，页号2没有越界，其存放的内存块号b=8
3. 物理地址E=b\*L+W=8\*1024+425=8644

在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。


## 具有快表的地址变换机构

### 局部性原理

```java
int i=0;
int a[100];
while(i<100){
    a[i]=i;
    i++;
}
```

![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229175757.png)

以上面这段代码为例，10号内存块中存放了程序执行涉及到的相关指令，23号代码块中存放了程序定义的变量，在程序执行过程中，显而易见会频繁的访问到10号和23号代码块

在此基础上，我们引申出来时间与空间的局部性

- 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)
  - 以上面代码为例，我们定义了变量i，那么我们极有可能在之后频繁的调用变量i（在上文的while循环中不断执行累加操作）
- 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)
  - 以上面的代码为例，我们创建了长度为100的数组a，并且为数组第一位赋值为0，那么我们接下来既有可能回去访问它的第二位第三位（在上文中按顺序为数组循环赋值）


上问介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，人们就考虑利用这个特性减少访问页表的次数

### 快表概念

快表，又称联想寄存器（TLB），是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

快表执行过程
![](https://ywrbyimg.oss-cn-chengdu.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20211229180721.png)


### 引入快表后，地址变换的过程

1. CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意:在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上。

例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?

```
(1+100)* 0.9+(1+100+100)* 0.1 =111 us

有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是
(1+100)*0.9+(100+100)* 0.1=110.9 us

若未采用快表机制，则访问一个逻辑地址需要
100+100= 200us
```

显然，引入快表机制后，访问一个逻辑地址的速度快多了。